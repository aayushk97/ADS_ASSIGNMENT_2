https://www.youtube.com/watch?v=jp_HSsOTTeg&t=13s

http://tutorials.jenkov.com/java-concurrency/index.html

https://www.coursera.org/specializations/pcdp

https://howtodoinjava.com/java-concurrency-tutorial/

https://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html

https://www.vogella.com/tutorials/JavaConcurrency/article.html

http://www.ryanhmckenna.com/2014/12/multi-core-programming-with-java.html

https://www.embedded.com/using-java-to-deal-with-multicore-programming-complexity-part-1/

https://en.wikipedia.org/wiki/Data_parallelism

https://en.wikipedia.org/wiki/Task_parallelism

https://www.shellscript.sh/first.html


Each fragment has a level,
Assuming that F1 combines with F2 it can only do that when
level(F1) <= level(F2)
i. Rule LT: If level(F1) < level(F2) then all the nodes in F1 take on the name and level of F2.
ii. Rule EQ: If level(F1) = level(F2) then level of both fragments are incremented by 1. The node of F1 union F2 is assigned a higher level.
 New name is eF + 1, where eF is name of minimum weight combining edge.
iii. Rule Wait: wait till any of the above rules apply.
 
 
wakeup():
1. Find the min weight edge connected to this node.
2. Set the state of edge to 1 and add this edge to MST.
3. Set the level to 0, state to 2 of this node.
4. Create a new message with id, args and weight of min weight edge.
5. Send the message to node connected with this edge.

addmessage():
1. The node which receives the message will add it in it's buffer(An message array/queue)

When it switches to other thread
readMessage():
1. If there are messages in its queue.
2. We take the message and compare the value of edge weight we received with the edges connected to this node.
3. A switch case is used to handle the message appropriately.
4. If the message is type 0 we call connect with 
